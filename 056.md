ShadowForce

medium

# Function signature may have hash collision

## Summary
Function signature may have hash collision
## Vulnerability Detail
A birthday attack is a type of cryptographic attack that exploits the mathematical principle of the birthday paradox to find collisions in a hash function.

The birthday paradox states that if you have a group of n people, the probability that any two of them share the same birthday is much higher than you might expect. Specifically, the probability of a collision is approximately 50% when the number of people is around the square root of the number of possible birthdays.

In the context of hash functions, a birthday attack works by generating a large number of random inputs and hashing them to create a set of hash values. Because the output of a hash function is typically much smaller than the input, there will be many more possible inputs than outputs, which means that collisions are likely to occur.

By using a variant of the birthday paradox, an attacker can calculate the probability of finding a collision in a hash function with a given output size and number of inputs. They can then use this probability to determine the number of inputs they need to generate in order to find a collision with a high degree of probability.

In summary, a birthday attack is a technique used to find collisions in a hash function by exploiting the birthday paradox to reduce the amount of computation required to find a collision. It is a powerful technique that can be used to break many cryptographic protocols that rely on hash functions, which is why hash functions are designed to be resistant to birthday attacks by using large output sizes and secure hashing algorithms.

```solidity
    L1InfoFuncSignature = "setL1BlockValues(uint64,uint64,uint256,bytes32,uint64,bytes32,uint256,uint256)"
    L1InfoArguments     = 8
    L1InfoLen           = 4 + 32*L1InfoArguments
)

var (
    L1InfoFuncBytes4       = crypto.Keccak256([]byte(L1InfoFuncSignature))[:4]
    L1InfoDepositerAddress = common.HexToAddress("0xdeaddeaddeaddeaddeaddeaddeaddeaddead0001")
    L1BlockAddress         = predeploys.L1BlockAddr
)
```
below is a link to the pr that includes the code shown above.
https://github.com/ethereum-optimism/optimism/pull/4936/files

in the snippet above, we see the protocol opted to generate a signature for the function. I think it is trivial and not in best interest of the protocol to do this. Like i have explained above, an attacker can find a string whose hash has the same four signature bytes as the one used in `L1InfoFuncBytes4`. The attacker can then input invalid data.

This collision already happens in the function `transfer(address,uint256)`. You can view all the possible collisions in the link below:
https://www.4byte.directory/signatures/?bytes4_signature=0xa9059cbb

A similar attack can be view in the poly network hack

> The attacker computed the 32-bit ID for putCurEpochConPubKeyBytes: 
ethers.utils.id ('putCurEpochConPubKeyBytes(bytes)').slice(0, 10)'0x41973cd9' 

>The attacker brute-forced a string that, if set as _method in the code snippet above, gives the same 32-bit value. In this case the attacker used the string “f1121318093”: 
>ethers.utils.id ('f1121318093(bytes,bytes,uint64)').slice(0, 10)'0x41973cd9' 
https://research.kudelskisecurity.com/2021/08/12/the-poly-network-hack-explained/

## Impact

## Code Snippet
https://github.com/ethereum-optimism/optimism/pull/4936/files
## Tool used

Manual Review

## Recommendation
validate the address that emits the event as well to avoid the collision attack
