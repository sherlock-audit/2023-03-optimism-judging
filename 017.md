MaanVader

medium

# Potential overflow/underflow in the function `depositTransaction()` which may allow funds to be lost and transferred to a wrong address

## Summary
The `depositTransaction` function in the Optimism Portal contract is vulnerable to integer overflow/underflow because it uses the `applyL1ToL2Alias` function which can overflow. If an attacker can trigger an overflow or underflow, the alias generated by the function can be incorrect and the funds may be sent to an unintended address.

## Vulnerability Detail
The vulnerability lies in the `applyL1ToL2Alia`s function which uses the `unchecked{}` keyword that can overflow if the input values are too large or underflow if the input values are too small. The `depositTransaction` function uses this function to transform the from-address to its alias if the caller is a contract. If an attacker can trigger an overflow or underflow, the alias generated by the function can be incorrect and the funds may be sent to an unintended address.

## Impact
If an attacker can trigger an overflow or underflow, the `applyL1ToL2Alias` function will generate an incorrect alias and the funds may be sent to an unintended address. This can result in the loss of funds for the user who deposited them. If an attacker can repeatedly trigger this function with an address that can overflow/underflow, it can result in a denial-of-service (DoS) attack on function disallowing other users to call the function.

## Code Snippet
`depositTransaction` function
* https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L426-#L465

```solidity
function depositTransaction(
    address _to,
    uint256 _value,
    uint64 _gasLimit,
    bool _isCreation,
    bytes memory _data
) public payable metered(_gasLimit) {
    // Just to be safe, make sure that people specify address(0) as the target when doing
    // contract creations.
    if (_isCreation) {
        require(
            _to == address(0),
            "OptimismPortal: must send to address(0) when creating a contract"
        );
    }

    // Prevent depositing transactions that have too small of a gas limit.
    require(_gasLimit >= 21_000, "OptimismPortal: gas limit must cover instrinsic gas cost");

    // Transform the from-address to its alias if the caller is a contract.
    address from = msg.sender;
    if (msg.sender != tx.origin) {
        from = AddressAliasHelper.applyL1ToL2Alias(msg.sender); @audit //can overflow and underflow
    }

    // Compute the opaque data that will be emitted as part of the TransactionDeposited event.
    // We use opaque data so that we can update the TransactionDeposited event in the future
    // without breaking the current interface.
    bytes memory opaqueData = abi.encodePacked(
        msg.value,
        _value,
        _gasLimit,
        _isCreation,
        _data
    );

    // Emit a TransactionDeposited event so that the rollup node can derive a deposit
    // transaction for this deposit.
    emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);
}

```
the issue in the function above is that when a user uses an msg.sender value which is not equal to the tx.origin address the function `applyL1ToL2Alias(msg.sender)` is called. If an attacker uses a specific `msg.sender` address this can potentially cause an overflow/underflow as the function  `applyL1ToL2Alias` is vulnerable to it.

Function `applyL1ToL2Alias()`
* https://github.com/ethereum-optimism/optimism/blob/9b9f78c6613c6ee53b93ca43c71bb74479f4b975/packages/contracts-bedrock/contracts/vendor/AddressAliasHelper.sol#L22-L32
*
```solidity
    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);

    /// @notice Utility function that converts the address in the L1 that submitted a tx to
    /// the inbox to the msg.sender viewed in the L2
    /// @param l1Address the address in the L1 that triggered the tx to L2
    /// @return l2Address L2 address as viewed in msg.sender
    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {
        unchecked {
            l2Address = address(uint160(l1Address) + offset);
        }
    }

```
In the function above it uses the `unchecked` statement to add `uint160` address and the `offset` which by manipulating the value of `l1address` can cause an overflow/underflow


## POC for underflow/overflow in the function 
add this to the foundry test of `AddressAliasHelper.t.sol`
```foundry
uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);

    function test_overflow() public {
        // Test address that will overflow when added to the offset
        address l1Address = address(0x1111111111111111111111111111111111111111);

        // Expect overflow when converting to L2 address
        assert(
            AddressAliasHelper.applyL1ToL2Alias(l1Address) == address(uint160(0))
        );
    }

     function testUnderflow() public {
        // Test address that will underflow when added to the offset
        address l1Address = address(0x0000000000000000000000000000000000000001);

        // Expect underflow to occur when converting to L2 address
        address unaliased = address(uint160(l1Address) - offset);
        assert(
             AddressAliasHelper.applyL1ToL2Alias(l1Address) == unaliased
        );
    }

    function test_normal() public {
        // Test address that won't overflow when added to the offset
        address l1Address = address(0x1234567890123456789012345678901234567890);

        // Expect normal behavior when converting to L2 address
        address unaliased = address(uint160(l1Address) + offset);
        assert(
            AddressAliasHelper.applyL1ToL2Alias(l1Address) == unaliased
        );
    }


```
Output:
```foundry
[⠢] Compiling...
No files changed, compilation skipped

Running 3 tests for test/AddressAliasHelper.t.sol:AddressAliasHelper_applyAndUndo_Test
[FAIL. Reason: Arithmetic over/underflow] testUnderflow() (gas: 258)
Traces:
  [258] helper::testUnderflow() 
    └─ ← "Arithmetic over/underflow"

[PASS] test_normal() (gas: 363)
Traces:
  [363] helper::test_normal() 
    └─ ← ()

[FAIL. Reason: Assertion violated] test_overflow() (gas: 205)       
Traces:
  [205] helper::test_overflow() 
    └─ ← "Assertion violated"

Test result: FAILED. 1 passed; 2 failed; finished in 441.60µs       

Failing tests:
Encountered 2 failing tests in test/AddressAliasHelper.t.sol:AddressAliasHelper_applyAndUndo_Test
[FAIL. Reason: Arithmetic over/underflow] testUnderflow() (gas: 258)
[FAIL. Reason: Assertion violated] test_overflow() (gas: 205)       

Encountered a total of 2 failing tests, 1 tests succeeded

```

## Tool used
*Manual Review
* Foundry



## Recommendation
To handle overflow and underflow cases in the `applyL1ToL2Alias` function or the `depositTransaction`, the function should be updated to validate the input values and return an error if overflow or underflow is detected. This can be achieved by adding input validations and using safe math functions, such as OpenZeppelin's SafeMath library, to perform arithmetic operations.
